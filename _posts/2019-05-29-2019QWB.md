---
layout:     post
title:      "2019强网杯writeup"
subtitle:   "PWN+Reverse部分"
date:       2018-05-29 11:00:00
author:     "Chris"
catalog: true
tags:
    - Pwn
    - CTF
    - Reverse
 
---
> 持续更新中.....

# Reverse

### JustRe

1. 程序主要逻辑： 

输入为26个字符，过两个check即可得到flag：

![](/img/pic/2019QWB/1.jpg)


2. check1：

把前8个字符转成4字节16进制：“12345678” ---> 0x12345678

![](/img/pic/2019QWB/2.jpg)

同理下面代码不贴出来了，把第9、10个字符同样转成1字节16进制。

接下来是一系列sse指令操作,伪代码中v21是输入的第9-10位，v9是第1-8位

![](/img/pic/2019QWB/3.jpg)


![](/img/pic/2019QWB/4.jpg)

这段代码是实质是 根据输入v21与v9 把0x405018处的0x40字节解密

接下来是一个循环操作：

![](/img/pic/2019QWB/6.jpg)

v3是输入的1-8位，v11是9-10位，根据v3与v11 将0x405058处8个dword(0x20)的数据依次解密。

上面那些操作实际上完成了对0x405018-0x405078一共0x60字节数据的解密操作。

然后就是比较了，将0x405018与0x404148处的前0x60字节数据进行比较，若相同就将0x404148处的数据copy入0x405018

![](/img/pic/2019QWB/7.jpg)

这就是第一个check，将代码自修改，为第二个check做准备。

Py对上面的循环 v3与v11约束条件爆破，得到输入的前10位

```python
loc_405058=(0x1e47913f,0x1e87963c,0xfa0b0acd,0x035b0958,0xf5e74cf4,0xfa1261dc,0x854b2f05,0xf852ed82)


loc_404188=(0x24448840,0x24848d4c,0x000001fc,0x0f50006a,0x1c244411,0x000f58e8,0x8d406a00,0x02482484)


flag=0x10

table = '0123456789'
for i1 in (table):
	print i1
	for i2 in (table):
		print "eee= " +i2
		for i3 in table:
			for i4 in table:
				for i5 in table:
					for i6 in table:
						for i7 in table:
							for i8 in table:
								for i9 in table:
									for i10 in table:
										tmp = i1+i2+i3+i4+i5+i6+i7+i8
										ReR = int(tmp,16)
										ReL = int((i9 + i10),16)

										for i  in range(8):
											if ( (flag+ReR)^((0x1010101 * ReL +loc_405058[i])&0xffffffff)== loc_404188[i]):
												flag=flag+1
											else:
												flag=0x10
												break
										if (flag==0x18):
											print "flag :  " +i1+i2+i3+i4+i5+i6+i7+i8+i9+i10

```
得到flag前10位 1324220819

3. check2


IDA 现在无法反编译sub_4018A0()为伪代码，可以用winhex直接修改exe，手动把 sub_4018A0() 处的字节覆盖为新函数的字节。

再反编译

![](/img/pic/2019QWB/9.jpg)

对输入分组 8字节一组 补齐24字节，填充模式为：PKCS5 (padding的字节数目为8-(x%8))


![](/img/pic/2019QWB/10.jpg)


![](/img/pic/2019QWB/11.jpg)

进行了根据经验有点像des加密，多次des加密，猜测是3des加密。


然后加密结果与 507ca9e68709cefa20d50dcf90bb976c9090f6b07ba6a4e8 比较(后面8字节为填充字节的加密结果)

![](/img/pic/2019QWB/12.jpg)

动态调试时获取的192位的密钥 AFSAFCEDYCXCXACNDFKDCQXC

在线解密

![](/img/pic/2019QWB/13.jpg)

得到后16位输入 0dcc509a6f75849b

再加上前10位 flag = 13242208190dcc509a6f75849b

![](/img/pic/2019QWB/14.jpg)

bingo

[下载链接](https://github.com/yxshyj/project/tree/master/reverse/JustRe)

### webassembly

在本地搭了一个www服务器动态调试，使用了WABT: The WebAssembly Binary Toolkit 反编译wasm文件找到main函数在func16

![](/img/pic/2019QWB/15.jpg)

![](/img/pic/2019QWB/16.jpg)

func15为加密与验证函数，在里面得出flag为38位

![](/img/pic/2019QWB/17.jpg)

常量delta=0x9e3779b9猜测是xtea加密

将明文前32位分四组迭代了32次分别进行xtea加密，动态调试分析到key=[0,0,0,0]
最后结果与固定常量异或求和。

![](/img/pic/2019QWB/18.jpg)


Py脚本:

```python
key = [0,0,0,0]
def xtea(rounds,v,key):
	v0 = v[0]
	v1 = v[1]
	delta = 0x9e3779b9
	sum = delta*rounds
	sum = sum & 0xffffffff
	for i in range(rounds):
		v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum>>11) & 3])
		v1 = v1 & 0xffffffff
		sum -= delta
		sum = sum & 0xffffffff
		v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum & 3])
		v0 = v0 & 0xffffffff
	v[0] = v0
	v[1] = v1


data = [183,-1,28,-19,30,11,115,8,122,-33,-78,29,-83,-22,-26,-96,-94,83, 23,-110,58,63,-16,-58,-6,68,-40,-98,82, 123,-128,48,98,98,99,98,57,125]
#print len(data)
for i in range(len(data)):
	data[i] = data[i] & 0xff
	
cipher = []
for i in range(0,len(data)-9,4):
	data2 = data[i]<<0
	data2 = data2 | (data[i+1]<<8)
	data2 = data2 | (data[i+2]<<16)
	data2 = data2 | (data[i+3]<<24)
	cipher.append(data2)

flag = ''

for i in range(0,len(cipher),2):
	de = []
	de.append(cipher[i])
	de.append(cipher[i+1])
	xtea(32,de,key)
	for j in range(0,len(de)):
		flag += hex(de[j])[2:-1].decode('hex')[::-1]

for i in range(len(data)-6,len(data)):
	flag += chr(data[i])

print flag


```

[下载链接](https://github.com/yxshyj/project/tree/master/reverse/webassembly)

# Pwn

### random


### babycpp
